<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wilson&#39;s Blog</title>
  
  <subtitle>我们是谁，我们是共产主义接班人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-02T13:03:16.387Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wilson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨越AppDomain边界访问对象</title>
    <link href="http://yoursite.com/2018/11/01/%E8%B7%A8%E8%B6%8AAppDomain%E8%BE%B9%E7%95%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/01/跨越AppDomain边界访问对象/</id>
    <published>2018-11-01T06:45:17.000Z</published>
    <updated>2018-11-02T13:03:16.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨越AppDomain边界访问对象"><a href="#跨越AppDomain边界访问对象" class="headerlink" title="跨越AppDomain边界访问对象"></a>跨越AppDomain边界访问对象</h1><h3 id="1-使用”按引用封送“进行跨AppDomain通信"><a href="#1-使用”按引用封送“进行跨AppDomain通信" class="headerlink" title="1. 使用”按引用封送“进行跨AppDomain通信"></a>1. 使用”按引用封送“进行跨AppDomain通信</h3><hr><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 获取AppDomain引用（“调用线程”当前正在该AppDomain中执行）</span><br><span class="line">AppDomain adCallingThreadDomain = Thread.GetDomain();</span><br><span class="line"></span><br><span class="line">// 每个AppDomain都分配了友好字符串名称（调试）</span><br><span class="line">String callingDomianName = adCallingThreadDomain.FriendlyName;</span><br><span class="line">Console.WriteLine($&quot;Friendly Name: &#123;callingDomianName&#125;&quot;);</span><br><span class="line"></span><br><span class="line">// 获取并显示AppDoMain中包含了“Main”方法的程序集</span><br><span class="line">String exeAssembly = Assembly.GetEntryAssembly().FullName;</span><br><span class="line">Console.WriteLine($&quot;Main Assembly: &#123;exeAssembly&#125;&quot;);</span><br><span class="line"></span><br><span class="line">// *** DEMO 1: 使用Marshal-by-Reference进行跨AppDomain通信 ***</span><br><span class="line">Console.WriteLine($&quot;&#123;Environment.NewLine&#125;Demo #1&quot;);</span><br><span class="line"></span><br><span class="line">// 新建一个AppDomain（从当前AppDomain继承安全性和配置）</span><br><span class="line">var ad2 = AppDomain.CreateDomain(&quot;AD #2&quot;, null, null);</span><br><span class="line"></span><br><span class="line">// 将我们的程序集加载到新的AppDoaming中，构造一个对象，</span><br><span class="line">// 把它封送回我们的AppDomain中（实际得到对一个代理的引用）</span><br><span class="line">var mbrt = (MarshalByRefType) ad2.CreateInstanceAndUnwrap(exeAssembly,typeof(MarshalByRefType).FullName);</span><br><span class="line">Console.WriteLine($&quot;Type: &#123;mbrt.GetType()&#125;&quot;); //CLR在类型上撒谎了</span><br><span class="line"></span><br><span class="line">// 证明得到的是对一个代理对象的引用</span><br><span class="line">Console.WriteLine($&quot;Is Proxy: &#123;RemotingServices.IsTransparentProxy(mbrt)&#125;&quot;);</span><br><span class="line"></span><br><span class="line">// 看起来像是在MarshalByRefType上调用一个方法，实则不然，我们是在代理类型上调用一个方法，</span><br><span class="line">// 代理使线程切换到拥有对象的那个AppDomain，并在真实对象上调用这个方法</span><br><span class="line">mbrt.SomeMethod();</span><br><span class="line"></span><br><span class="line">//卸载AppDomain</span><br><span class="line">AppDomain.Unload(ad2);</span><br><span class="line"></span><br><span class="line">// mbrt引用一个有效的代理对象；代理对象引用一个无效的AppDomain</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    // 在代理类型上调用一个方法。AppDomain无效，造成抛出异常</span><br><span class="line">    mbrt.SomeMethod();</span><br><span class="line">    Console.WriteLine(&quot;Successful call.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch (AppDomainUnloadedException e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;Failed call.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>通过CreateDomain创建一个名叫”AD #2”的AppDomain，从当前AppDomain继承安全性和配置设置</li><li>将程序集加载到新的AppDomain中，通过新的AppDomain中的程序集创建MarshalByRefType的实例，并返回对MarshalByRefType的引用（由于CLR不允许一个AppDomain中的变量引用另一个AppDomain中创建的对象，所以从CreateInstanceAndUnwrap返回的对象实际不是CreateInstanceAndUnwrap类型的实例）</li><li>由于mbrt变量引用一个代理对象，所以会调用代理对象的SomeMethod方法。代理的实现利用代理对象中的信息字段，将调用线程从默认的AppDomain切换至新的AppDomain中，正式的SomeMethod方法返回后，会返回至代理的SomeMethod方法，后者会将线程切换回默认的AppDomain中</li><li>通过调用Unload方法卸指定的AppDomain，并强行执行一次垃圾回收，以释放由卸载的AppDomain中的代码创建的所有对象</li><li>当AppDomain试图使用代理对象调用SomeMethod方法时，会抛出一个AppDomainUnloadedException异常（虽然mbrt对象仍引用一个有效的代理对象，但代理对象不再引用一个有效的AppDomain）</li></ol><p>输出：</p><p><img src="./1-1.PNG" alt="1-1"></p><h3 id="2-使用”按值封送“进行跨AppDomain通信"><a href="#2-使用”按值封送“进行跨AppDomain通信" class="headerlink" title="2. 使用”按值封送“进行跨AppDomain通信"></a>2. 使用”按值封送“进行跨AppDomain通信</h3><hr><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// *** DEMO 2: 使用Marshal-by-Value进行跨AppDomain通信 ***</span><br><span class="line">Console.WriteLine($&quot;&#123;Environment.NewLine&#125;Demo #2&quot;);</span><br><span class="line"></span><br><span class="line">// 新建一个AppDomain（从当前AppDomain继承安全性和配置）</span><br><span class="line">ad2 = AppDomain.CreateDomain(&quot;AD #2&quot;, null, null);</span><br><span class="line"></span><br><span class="line">// 将我们的程序集加载到新的AppDoaming中，构造一个对象，</span><br><span class="line">// 把它封送回我们的AppDomain中（实际得到对一个代理的引用）</span><br><span class="line">mbrt = (MarshalByRefType) ad2.CreateInstanceAndUnwrap(exeAssembly, typeof(MarshalByRefType).FullName);</span><br><span class="line"></span><br><span class="line">// 对象的方法返回所返回对象的副本</span><br><span class="line">// 对象按值（而非按引用）封送</span><br><span class="line">var mbvt = mbrt.MethodWithReturn();</span><br><span class="line"></span><br><span class="line">// 证明得到的不是对一个代理对象的引用</span><br><span class="line">Console.WriteLine($&quot;Is Proxy: &#123;RemotingServices.IsTransparentProxy(mbvt)&#125;&quot;);</span><br><span class="line"></span><br><span class="line">// 看起来是在MarshalByValType上调用一个方法，实际也是如此</span><br><span class="line">Console.WriteLine($&quot;Returned object created &#123;mbvt.ToString()&#125;&quot;);</span><br><span class="line"></span><br><span class="line">// 卸载新的AppDomain</span><br><span class="line">AppDomain.Unload(ad2);</span><br><span class="line"></span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    // 我们是在对象上调用一个方法：不会抛出异常</span><br><span class="line">    Console.WriteLine($&quot;Returned object created &#123;mbvt.ToString()&#125;&quot;);</span><br><span class="line">    Console.WriteLine($&quot;Successful call.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch (AppDomainUnloadedException e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;Failed call.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>通过CreateDomain创建一个名叫”AD #2”的AppDomain，从当前AppDomain继承安全性和配置设置</li><li>将程序集加载到新的AppDomain中，通过新的AppDomain中的程序集创建MarshalByRefType的实例，并返回对MarshalByRefType的引用（由于CLR不允许一个AppDomain中的变量引用另一个AppDomain中创建的对象，所以从CreateInstanceAndUnwrap返回的对象实际不是CreateInstanceAndUnwrap类型的实例）</li><li>代理调用MethodWithReturn方法在新的AppDomain中创建MarshByValType类型的实例，并将一个对象引用返回给默认AppDomain（由于MarshByValType类型不从MarshalByRefObject派生，所以对象不能按引用跨AppDomain边界进行封送；由于定义了Serializable特性，所以MethodWithReturn方法能按值封送对象）</li><li>通过调用Unload方法卸指定的AppDomain，并强行执行一次垃圾回收，以释放由卸载的AppDomain中的代码创建的所有对象</li><li>由于程序使用真实对象调用ToString方法，所以会调用这个方法的真实实现，线程不会再AppDomain中切换</li></ol><p>输出：</p><p><img src="./1-2.PNG" alt="1-2"></p><h3 id="3-使用不可封送的类型跨AppDomain通信"><a href="#3-使用不可封送的类型跨AppDomain通信" class="headerlink" title="3. 使用不可封送的类型跨AppDomain通信"></a>3. 使用不可封送的类型跨AppDomain通信</h3><hr><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// *** DEMO 3: 使用不可封送的类型进行跨AppDomain通信 ***</span><br><span class="line">Console.WriteLine($&quot;&#123;Environment.NewLine&#125;Demo #3&quot;);</span><br><span class="line"></span><br><span class="line">// 新建一个AppDomain（从当前AppDomain继承安全性和配置）</span><br><span class="line">ad2 = AppDomain.CreateDomain(&quot;AD #2&quot;, null, null);</span><br><span class="line"></span><br><span class="line">// 将我们的程序集加载到新的AppDoaming中，构造一个对象，</span><br><span class="line">// 把它封送回我们的AppDomain中（实际得到对一个代理的引用）</span><br><span class="line">mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeAssembly,typeof(MarshalByRefType).FullName);</span><br><span class="line"></span><br><span class="line">// 对象的方法返回一个不可封送的对象：抛出异常</span><br><span class="line">var nmt = mbrt.MethodArgAndReturn(callingDomianName);</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li><p>通过CreateDomain创建一个名叫”AD #2”的AppDomain，从当前AppDomain继承安全性和配置设置</p></li><li><p>将程序集加载到新的AppDomain中，通过新的AppDomain中的程序集创建MarshalByRefType的实例，并返回对MarshalByRefType的引用（由于CLR不允许一个AppDomain中的变量引用另一个AppDomain中创建的对象，所以从CreateInstanceAndUnwrap返回的对象实际不是CreateInstanceAndUnwrap类型的实例）</p></li><li><p>mbrt调用MethodArgAndReturn方法创建了一个NonMarshalableType对象，由于NonMarshalableType对象没有从MarshalByRefObject派生也没有用Serializable定制特性进行标记，所以MethodArgAndReturn不能按引用或按值封送对象，导致MethodArgAndReturn方法抛出一个SerializationException异常（由于CLR的优化String对象不会真的生成副本，只是传递了一个引用）</p></li></ol><p>输出：</p><p><img src="./1-3.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;跨越AppDomain边界访问对象&quot;&gt;&lt;a href=&quot;#跨越AppDomain边界访问对象&quot; class=&quot;headerlink&quot; title=&quot;跨越AppDomain边界访问对象&quot;&gt;&lt;/a&gt;跨越AppDomain边界访问对象&lt;/h1&gt;&lt;h3 id=&quot;1-使用”
      
    
    </summary>
    
      <category term="CLR via C#" scheme="http://yoursite.com/categories/CLR-via-C/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="CLR via C#" scheme="http://yoursite.com/tags/CLR-via-C/"/>
    
  </entry>
  
</feed>
